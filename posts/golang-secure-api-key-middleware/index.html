<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Implementing a safe and sound API Key authorization middleware in Go | Simple Made Daily</title><meta name=keywords content="go,security,authorization,authentication"><meta name=description content="How to design a more secure API Key handling in Go"><meta name=author content="Caio Ferreira"><link rel=canonical href=https://caioferreira.dev/posts/golang-secure-api-key-middleware/><meta name=google-site-verification content="G-520NXKH2M6"><link crossorigin=anonymous href=/assets/css/stylesheet.d53593ac5b971ecf76b17a47ca5e9838cbe9f27c71a39c42e20c4361a252c9c0.css integrity="sha256-1TWTrFuXHs92sXpHyl6YOMvp8nxxo5xC4gxDYaJSycA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://caioferreira.dev/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://caioferreira.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://caioferreira.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://caioferreira.dev/apple-touch-icon.png><link rel=mask-icon href=https://caioferreira.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/atom-one-dark.min.css integrity="sha512-Fcqyubi5qOvl+yCwSJ+r7lli+CO1eHXMaugsZrnxuU4DVpLYWXTVoHy55+mCb4VZpMgy7PBhV7IiymC0yu9tkQ==" crossorigin=anonymous referrerpolicy=no-referrer><script async src="https://www.googletagmanager.com/gtag/js?id=G-520NXKH2M6"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-520NXKH2M6",{anonymize_ip:!1})}</script><meta property="og:title" content="Implementing a safe and sound API Key authorization middleware in Go"><meta property="og:description" content="How to design a more secure API Key handling in Go"><meta property="og:type" content="article"><meta property="og:url" content="https://caioferreira.dev/posts/golang-secure-api-key-middleware/"><meta property="og:image" content="https://caioferreira.dev/posts/golang-secure-api-key-middleware/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-05T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-05T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://caioferreira.dev/posts/golang-secure-api-key-middleware/cover.jpg"><meta name=twitter:title content="Implementing a safe and sound API Key authorization middleware in Go"><meta name=twitter:description content="How to design a more secure API Key handling in Go"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://caioferreira.dev/posts/"},{"@type":"ListItem","position":2,"name":"Implementing a safe and sound API Key authorization middleware in Go","item":"https://caioferreira.dev/posts/golang-secure-api-key-middleware/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Implementing a safe and sound API Key authorization middleware in Go","name":"Implementing a safe and sound API Key authorization middleware in Go","description":"How to design a more secure API Key handling in Go","keywords":["go","security","authorization","authentication"],"articleBody":" A common requirement that I face on multiple projects is to safeguard some API endpoints to administrative access, or to provide a secure way for other applications to consume our service in a controlled and traceable manner.\nThe usual solution for it is API Keys, a simple and effective authorization control mechanism that we can implement with a few lines of code. However, when doing, so we also need to be aware of threats and possible attacks that we may suffer, specially due to the usual privileges that these keys provides.\nTherefore, we are going to analyze common points of concern and design a solution that improve our security posture while keeping it simple.\nAPI Keys threats There are two main concerns when implementing an API Key authorization scheme: key provisioning and timing attacks. Let’s review each threat before designing solutions to address them.\nKey Provisioning The key storage is directly related to how applications expect these secrets to be provided to them. Environment variables are the most common solution used on modern services since they are widely supported and don’t incur a high reading cost (in contrast to files) allowing for dynamic changes to be easily detected.\nHowever, the way developers usually define the environment variables are through scripts or configuration files, for example using a Kubernetes Secret manifest. This introduces a serious threat of API Keys being committed to git repositories, which in the event of data leakage from the internal VCS management system would expose these credentials.\nNote: remember that once committed, even if the keys are deleted from the source files, the information is already on the repository history and is easily searchable with tools like TruffleHog.\nTherefore, please do not commit your API Keys to git!\nTiming Attacks Once your application is configured with the available API Keys, you need to verify that the end-user provided key (let’s call this the user key) is correct. Doing so with a naive algorithm, like using == operator, will make the verification end on the first incorrect character, hence reducing the time taken to respond.\nA timing attack takes advantage of this scenario by trying to guess the correct characters of a secret based on how long the application took to respond. If the guess is right, the response will take slightly longer than if it’s wrong.\nNaturally, since equality checks are orders of magnitude faster than the network roundtrip, this type of attack is extremely difficult to perform because it depends on a statistical analysis of many response samples. By looking at the time distribution produced by two different characters, one can infer that if they are different, inferring that the greater one is the correct value. For an extensive discussion of statistical techniques to help perform this attack see Morgan, Morgan 2015.\nMiddleware design and implementation Having these threats in mind, we can design a suitable solution. Let’s start with the most simple API Key middleware implementation possible and iterate from it.\nfunc ApiKeyMiddleware(cfg conf.Config, logger logging.Logger) func(handler http.Handler) http.Handler { apiKeyHeader := cfg.APIKeyHeader // string apiKeys := cfg.APIKeys // map[string]string reverseKeyIndex := make(map[string]string) for name, key := apiKeys { reverseKeyIndex[key] = name } return func(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { apiKey, err := bearerToken(r, apiKeyHeader) if err != nil { logger.Errorw(\"request failed API key authentication\", \"error\", err) RespondError(w, http.StatusUnauthorized, \"invalid API key\") return } _, found := reverseKeyIndex[apiKey] if !found { hostIP, _, err := net.SplitHostPort(r.RemoteAddr) if err != nil { logger.Errorw(\"failed to parse remote address\", \"error\", err) hostIP = r.RemoteAddr } logger.Errorw(\"no matching API key found\", \"remoteIP\", hostIP) RespondError(w, http.StatusUnauthorized, \"invalid api key\") return } next.ServeHTTP(w, r) }) } } // bearerToken extracts the content from the header, striping the Bearer prefix func bearerToken(r *http.Request, header string) (string, error) { rawToken := r.Header.Get(header) pieces := strings.SplitN(rawToken, \" \", 2) if len(pieces) \u003c 2 { return \"\", errors.New(\"token with incorrect bearer format\") } token := strings.TrimSpace(pieces[1]) return token, nil } A middleware is a function that takes an http.Handler and returns an http.Handler. In this code, the function ApiKeyMiddleware is a factory that creates an instance of the middleware with the provided configuration and logger. The config.Config is a struct populated from environment variables and logging.Logger is an interface that can be implemented using any logging library or the standard library. You could pass only the header and map of keys, but for clarity we choose to denote the dependency from this middleware to the configuration.\nAfter extracting the fields that it relies on, the function creates a reverse index of the API Keys, which is originally a map from a key id/name to the key value. Using this reverse index it’s trivial to verify if the user key is valid by doing a map lookup on line 18.\nHowever, this approach expects the API Keys as plaintext values and is susceptible to timing attacks, because its validation algorithm is not constant time.\nUsing key hashes for validation To improve the key provisioning workflow, we can use a simple yet effective solution: expect the available keys to be hashes. Using this approach we can now commit our key hashes to our repository because even in the event of a data leak they could not be reversed to their original value.\nLet’s use the SHA256 hashing algorithm to encode our keys. For example, if one of them is 123456789 (please, do not use a key like this :D) then its hash will be:\n15e2b0d3c33891ebb0f1ef609ec419420c20e320ce94c65fbc8c3312448eb225 Now you can add this hash to your deployment script, Kubernetes Secret, etc., and commit it with peace of mind.\nNext, we need to handle this new format on our middleware. This is what the code will look like now:\nfunc ApiKeyMiddleware(cfg conf.Config, logger logging.Logger) func(handler http.Handler) http.Handler { apiKeyHeader := cfg.APIKeyHeader // string apiKeys := cfg.APIKeys // map[string]string reverseKeyIndex := make(map[string]string) for name, key := apiKeys { reverseKeyIndex[key] = name } return func(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { apiKey, err := bearerToken(r, apiKeyHeader) if err != nil { logger.Errorw(\"request failed API key authentication\", \"error\", err) RespondError(w, http.StatusUnauthorized, \"invalid API key\") return } _, ok := apiKeyIsValid(apiKey, reverseKeyIndex) if !ok { hostIP, _, err := net.SplitHostPort(r.RemoteAddr) if err != nil { logger.Errorw(\"failed to parse remote address\", \"error\", err) hostIP = r.RemoteAddr } logger.Errorw(\"no matching API key found\", \"remoteIP\", hostIP) RespondError(w, http.StatusUnauthorized, \"invalid api key\") return } next.ServeHTTP(w, r) }) } } // apiKeyIsValid checks if the given API key is valid and returns the principal if it is. func apiKeyIsValid(rawKey string, availableKeys map[string][]byte) (string, bool) { hash := sha256.Sum256([]byte(rawKey)) key := string(hash[:]) name, found := reverseKeyIndex[apiKey] return name, found } // bearerToken function omitted.. Here we extracted the logic to validate the key into a function that, before checking the equality of the user key against the available ones, encodes the user key using the same SHA256 algorithm.\nThis simple step improved a lot our security posture without adding much complexity. Now we can have the benefits of version control, like change history and easy detection when someone changes a key hash.\nThis approach works well when there are few keys to be managed, and you want to follow a GitOps approach. However, if you need to scale the key management, allow for self-service key requests and automatic rotation, you may want to look for a solution like Hashicorp Vault. Even using an external secret store I still believe this strategy, to rely on key hashes to be valid, because your external secret store can persist both the original key and the hash, and the access policy for the application can have fewer privileges in such a way that it can only read the hashes.\nConstant time key verification Once we have a better strategy to provision our keys, we need to defend ourselves against them being exfiltrated by timing attacks. The solution for this kind of vulnerability is to use an algorithm that takes the same time to produce a result whether the keys are equal or not. This is called a constant time comparison, and the Go Standard Library offers us an implementation in the crypto/subtle package that is perfect to solve most of our problems. Hence, we can update our code to use this package:\nfunc ApiKeyMiddleware(cfg conf.Config, logger logging.Logger) (func(handler http.Handler) http.Handler, error) { apiKeyHeader := cfg.APIKeyHeader apiKeys := cfg.APIKeys apiKeyMaxLen := cfg.APIKeyMaxLen decodedAPIKeys := make(map[string][]byte) for name, value := range apiKeys { decodedKey, err := hex.DecodeString(value) if err != nil { return nil, err } decodedAPIKeys[name] = decodedKey } return func(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { ctx := r.Context() apiKey, err := bearerToken(r, apiKeyHeader) if err != nil { logger.Errorw(\"request failed API key authentication\", \"error\", err) RespondError(w, http.StatusUnauthorized, \"invalid API key\") return } if _, ok := apiKeyIsValid(apiKey, decodedAPIKeys); !ok { hostIP, _, err := net.SplitHostPort(r.RemoteAddr) if err != nil { logger.Errorw(\"failed to parse remote address\", \"error\", err) hostIP = r.RemoteAddr } logger.Errorw(\"no matching API key found\", \"remoteIP\", hostIP) RespondError(w, http.StatusUnauthorized, \"invalid api key\") return } next.ServeHTTP(w, r.WithContext(ctx)) }) }, nil } // apiKeyIsValid checks if the given API key is valid and returns the principal if it is. func apiKeyIsValid(rawKey string, availableKeys map[string][]byte) (string, bool) { hash := sha256.Sum256([]byte(rawKey)) key := hash[:] for name, value := range availableKeys { contentEqual := subtle.ConstantTimeCompare(value, key) == 1 if contentEqual { return name, true } } return \"\", false } // bearerToken function omitted... Now, the function apiKeyIsValid uses subtle.ConstantTimeCompare to verify the user key against each available key. Since subtle.ConstantTimeCompare operates upon byte slices we don’t cast our hash to string anymore and also our reversed index has gone in place of a decoded map.\nThe decoding is necessary because the string representation of our key hashes are actually a hexadecimal encoding of the binary value. Hence, we cannot just cast the string to byte slice because Go assumes all strings to be UTF-8 encoded.\nNote: for an example on how using a cast instead of the correct decoding function, the result of []byte(\"09\") is 110000111001 while hex.DecodeString(\"09\") produces 1001. Check out the live example here.\nThe major disadvantage of this solution is that now we need to iterate over all available keys before finding out if the key is incorrect. This doesn’t scale well if there are too many keys, however one simple workaround would be to require the client to send an extra header with the key ID/name, e.g. X-App-Key-ID, with which you can find the key in O(1) and then apply the constant time comparison.\nHowever, there is one subtle (pun intended) behavior from subtle.ConstantTimeCompare that we must be aware before deploying our solution to production. When the byte slices have different lengths, the functions returns earlier without performing the bitwise operations. This is natural because it does an XOR between each pair of bits from each slice, and with slices of different sizes, there would be bits from one slice without a matching pair to be combined with. Because of it, an adversary could measure that keys with the wrong length have a smaller response time than keys with the correct length, hence leaking the key length. It would only be a vulnerability if you use a short key that is easily brute-forced, but with a simple 30 character key using the UTF-8 printable characters you would have 30^95 = 2.12089515 × 10^140 possible keys.\nFinally, we’ve built a simple, secure and efficient API Key solution that should handle a lot of uses cases without additional infrastructure or complexity. Using a basic understanding of threats and the Golang standard library, we could do a security-oriented design instead of leaving security as an after-though in an iterative way.\nPhoto by Silas Köhler on Unsplash.\n","wordCount":"1951","inLanguage":"en","datePublished":"2022-02-05T00:00:00Z","dateModified":"2022-02-05T00:00:00Z","author":{"@type":"Person","name":"Caio Ferreira"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://caioferreira.dev/posts/golang-secure-api-key-middleware/"},"publisher":{"@type":"Organization","name":"Simple Made Daily","logo":{"@type":"ImageObject","url":"https://caioferreira.dev/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://caioferreira.dev/ accesskey=h title="Simple Made Daily (Alt + H)"><img src=https://caioferreira.dev/logo.png alt aria-label=logo height=28>Simple Made Daily</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://caioferreira.dev/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://caioferreira.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://caioferreira.dev/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Implementing a safe and sound API Key authorization middleware in Go</h1><div class=post-description>How to design a more secure API Key handling in Go</div><div class=post-meta><span title='2022-02-05 00:00:00 +0000 UTC'>February 5, 2022</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Caio Ferreira&nbsp;|&nbsp;<a href=https://github.com/caiorcferreira/caioferreira.dev/tree/main/content/posts/golang-secure-api-key-middleware/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p><img loading=lazy src=./cover.jpg alt></p><p>A common requirement that I face on multiple projects is to safeguard some API endpoints to administrative access, or to provide a secure way for other applications to consume our service in a controlled and traceable manner.</p><p>The usual solution for it is API Keys, a simple and effective authorization control mechanism that we can implement with a few lines of code. However, when doing, so we also need to be aware of threats and possible attacks that we may suffer, specially due to the usual privileges that these keys provides.</p><p>Therefore, we are going to analyze common points of concern and design a solution that improve our security posture while keeping it simple.</p><h2 id=api-keys-threats>API Keys threats<a hidden class=anchor aria-hidden=true href=#api-keys-threats>#</a></h2><p>There are two main concerns when implementing an API Key authorization scheme: <strong>key provisioning</strong> and <strong>timing attacks</strong>. Let&rsquo;s review each threat before designing solutions to address them.</p><h3 id=key-provisioning>Key Provisioning<a hidden class=anchor aria-hidden=true href=#key-provisioning>#</a></h3><p>The key storage is directly related to how applications expect these secrets to be provided to them. Environment variables are the most common solution used on modern services since they are widely supported and don&rsquo;t incur a high reading cost (in contrast to files) allowing for dynamic changes to be easily detected.</p><p>However, the way developers usually define the environment variables are through scripts or configuration files, for example using a <a href=https://kubernetes.io/docs/concepts/configuration/secret/>Kubernetes Secret</a> manifest. This introduces a serious threat of API Keys being committed to git repositories, which in the event of data leakage from the internal VCS management system would expose these credentials.</p><p>Note: remember that once committed, even if the keys are deleted from the source files, the information is already on the repository history and is easily searchable with tools like <a href=https://github.com/trufflesecurity/truffleHog>TruffleHog</a>.</p><p>Therefore, <strong>please do not commit your API Keys to git</strong>!</p><h3 id=timing-attacks>Timing Attacks<a hidden class=anchor aria-hidden=true href=#timing-attacks>#</a></h3><p>Once your application is configured with the available API Keys, you need to verify that the end-user provided key (let&rsquo;s call this the <em>user key</em>) is correct. Doing so with a naive algorithm, like using == operator, will make the verification end on the first incorrect character, hence reducing the time taken to respond.</p><p>A timing attack takes advantage of this scenario by trying to guess the correct characters of a secret based on how long the application took to respond. If the guess is right, the response will take slightly longer than if it&rsquo;s wrong.</p><p>Naturally, since equality checks are orders of magnitude faster than the network roundtrip, this type of attack is extremely difficult to perform because it depends on a statistical analysis of many response samples. By looking at the time distribution produced by two different characters, one can infer that if they are different, inferring that the greater one is the correct value. For an extensive discussion of statistical techniques to help perform this attack see <a href=https://www.blackhat.com/docs/us-15/materials/us-15-Morgan-Web-Timing-Attacks-Made-Practical-wp.pdf>Morgan, Morgan 2015</a>.</p><h2 id=middleware-design-and-implementation>Middleware design and implementation<a hidden class=anchor aria-hidden=true href=#middleware-design-and-implementation>#</a></h2><p>Having these threats in mind, we can design a suitable solution. Let&rsquo;s start with the most simple API Key middleware implementation possible and iterate from it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ApiKeyMiddleware</span><span class=p>(</span><span class=nx>cfg</span> <span class=nx>conf</span><span class=p>.</span><span class=nx>Config</span><span class=p>,</span> <span class=nx>logger</span> <span class=nx>logging</span><span class=p>.</span><span class=nx>Logger</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=nx>handler</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>apiKeyHeader</span> <span class=o>:=</span> <span class=nx>cfg</span><span class=p>.</span><span class=nx>APIKeyHeader</span> <span class=c1>// string
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>apiKeys</span> <span class=o>:=</span> <span class=nx>cfg</span><span class=p>.</span><span class=nx>APIKeys</span> <span class=c1>// map[string]string
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>reverseKeyIndex</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>key</span> <span class=o>:=</span> <span class=nx>apiKeys</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>reverseKeyIndex</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>name</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>next</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>apiKey</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>bearerToken</span><span class=p>(</span><span class=nx>r</span><span class=p>,</span> <span class=nx>apiKeyHeader</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>logger</span><span class=p>.</span><span class=nf>Errorw</span><span class=p>(</span><span class=s>&#34;request failed API key authentication&#34;</span><span class=p>,</span> <span class=s>&#34;error&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nf>RespondError</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusUnauthorized</span><span class=p>,</span> <span class=s>&#34;invalid API key&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>_</span><span class=p>,</span> <span class=nx>found</span> <span class=o>:=</span> <span class=nx>reverseKeyIndex</span><span class=p>[</span><span class=nx>apiKey</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>!</span><span class=nx>found</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>hostIP</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>SplitHostPort</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>RemoteAddr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>logger</span><span class=p>.</span><span class=nf>Errorw</span><span class=p>(</span><span class=s>&#34;failed to parse remote address&#34;</span><span class=p>,</span> <span class=s>&#34;error&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=nx>hostIP</span> <span class=p>=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>RemoteAddr</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=nx>logger</span><span class=p>.</span><span class=nf>Errorw</span><span class=p>(</span><span class=s>&#34;no matching API key found&#34;</span><span class=p>,</span> <span class=s>&#34;remoteIP&#34;</span><span class=p>,</span> <span class=nx>hostIP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=nf>RespondError</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusUnauthorized</span><span class=p>,</span> <span class=s>&#34;invalid api key&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>next</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// bearerToken extracts the content from the header, striping the Bearer prefix
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>bearerToken</span><span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>,</span> <span class=nx>header</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>rawToken</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>Header</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>header</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>pieces</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>SplitN</span><span class=p>(</span><span class=nx>rawToken</span><span class=p>,</span> <span class=s>&#34; &#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>pieces</span><span class=p>)</span> <span class=p>&lt;</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=s>&#34;token with incorrect bearer format&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>token</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>TrimSpace</span><span class=p>(</span><span class=nx>pieces</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>token</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>A middleware is a function that takes an <code>http.Handler</code> and returns an <code>http.Handler</code>. In this code, the function <code>ApiKeyMiddleware</code> is a factory that creates an instance of the middleware with the provided configuration and logger. The <code>config.Config</code> is a struct populated from environment variables and <code>logging.Logger</code> is an interface that can be implemented using any logging library or the standard library. You could pass only the header and map of keys, but for clarity we choose to denote the dependency from this middleware to the configuration.</p><p>After extracting the fields that it relies on, the function creates a reverse index of the API Keys, which is originally a map from a key id/name to the key value. Using this reverse index it&rsquo;s trivial to verify if the user key is valid by doing a map lookup on line 18.</p><p>However, this approach expects the API Keys as plaintext values and is susceptible to timing attacks, because its validation algorithm is not constant time.</p><h3 id=using-key-hashes-for-validation>Using key hashes for validation<a hidden class=anchor aria-hidden=true href=#using-key-hashes-for-validation>#</a></h3><p>To improve the key provisioning workflow, we can use a simple yet effective solution: expect the available keys to be hashes. Using this approach we can now commit our key hashes to our repository because even in the event of a data leak they could not be reversed to their original value.</p><p>Let&rsquo;s use the SHA256 hashing algorithm to encode our keys. For example, if one of them is <code>123456789</code> (please, do not use a key like this :D) then its hash will be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>15e2b0d3c33891ebb0f1ef609ec419420c20e320ce94c65fbc8c3312448eb225
</span></span></code></pre></div><p>Now you can add this hash to your deployment script, Kubernetes Secret, etc., and commit it with peace of mind.</p><p>Next, we need to handle this new format on our middleware. This is what the code will look like now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ApiKeyMiddleware</span><span class=p>(</span><span class=nx>cfg</span> <span class=nx>conf</span><span class=p>.</span><span class=nx>Config</span><span class=p>,</span> <span class=nx>logger</span> <span class=nx>logging</span><span class=p>.</span><span class=nx>Logger</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=nx>handler</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>apiKeyHeader</span> <span class=o>:=</span> <span class=nx>cfg</span><span class=p>.</span><span class=nx>APIKeyHeader</span> <span class=c1>// string
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>apiKeys</span> <span class=o>:=</span> <span class=nx>cfg</span><span class=p>.</span><span class=nx>APIKeys</span> <span class=c1>// map[string]string
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>reverseKeyIndex</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>key</span> <span class=o>:=</span> <span class=nx>apiKeys</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>reverseKeyIndex</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span> <span class=p>=</span> <span class=nx>name</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>next</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>apiKey</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>bearerToken</span><span class=p>(</span><span class=nx>r</span><span class=p>,</span> <span class=nx>apiKeyHeader</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>logger</span><span class=p>.</span><span class=nf>Errorw</span><span class=p>(</span><span class=s>&#34;request failed API key authentication&#34;</span><span class=p>,</span> <span class=s>&#34;error&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nf>RespondError</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusUnauthorized</span><span class=p>,</span> <span class=s>&#34;invalid API key&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nf>apiKeyIsValid</span><span class=p>(</span><span class=nx>apiKey</span><span class=p>,</span> <span class=nx>reverseKeyIndex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>hostIP</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>SplitHostPort</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>RemoteAddr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>logger</span><span class=p>.</span><span class=nf>Errorw</span><span class=p>(</span><span class=s>&#34;failed to parse remote address&#34;</span><span class=p>,</span> <span class=s>&#34;error&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=nx>hostIP</span> <span class=p>=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>RemoteAddr</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=nx>logger</span><span class=p>.</span><span class=nf>Errorw</span><span class=p>(</span><span class=s>&#34;no matching API key found&#34;</span><span class=p>,</span> <span class=s>&#34;remoteIP&#34;</span><span class=p>,</span> <span class=nx>hostIP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=nf>RespondError</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusUnauthorized</span><span class=p>,</span> <span class=s>&#34;invalid api key&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>next</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// apiKeyIsValid checks if the given API key is valid and returns the principal if it is.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>apiKeyIsValid</span><span class=p>(</span><span class=nx>rawKey</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>availableKeys</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>hash</span> <span class=o>:=</span> <span class=nx>sha256</span><span class=p>.</span><span class=nf>Sum256</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>rawKey</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>key</span> <span class=o>:=</span> <span class=nb>string</span><span class=p>(</span><span class=nx>hash</span><span class=p>[:])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>name</span><span class=p>,</span> <span class=nx>found</span> <span class=o>:=</span> <span class=nx>reverseKeyIndex</span><span class=p>[</span><span class=nx>apiKey</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>found</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// bearerToken function omitted..
</span></span></span></code></pre></div><p>Here we extracted the logic to validate the key into a function that, before checking the equality of the user key against the available ones, encodes the user key using the same SHA256 algorithm.</p><p>This simple step improved a lot our security posture without adding much complexity. Now we can have the benefits of version control, like change history and easy detection when someone changes a key hash.</p><p>This approach works well when there are few keys to be managed, and you want to follow a GitOps approach. However, if you need to scale the key management, allow for self-service key requests and automatic rotation, you may want to look for a solution like <a href=https://www.vaultproject.io>Hashicorp Vault</a>. Even using an external secret store I still believe this strategy, to rely on key hashes to be valid, because your external secret store can persist both the original key and the hash, and the access policy for the application can have fewer privileges in such a way that it can only read the hashes.</p><h3 id=constant-time-key-verification>Constant time key verification<a hidden class=anchor aria-hidden=true href=#constant-time-key-verification>#</a></h3><p>Once we have a better strategy to provision our keys, we need to defend ourselves against them being exfiltrated by timing attacks. The solution for this kind of vulnerability is to use an algorithm that takes the same time to produce a result whether the keys are equal or not. This is called a constant time comparison, and the Go Standard Library offers us an implementation in the <code>crypto/subtle</code> package that is perfect to solve most of our problems. Hence, we can update our code to use this package:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ApiKeyMiddleware</span><span class=p>(</span><span class=nx>cfg</span> <span class=nx>conf</span><span class=p>.</span><span class=nx>Config</span><span class=p>,</span> <span class=nx>logger</span> <span class=nx>logging</span><span class=p>.</span><span class=nx>Logger</span><span class=p>)</span> <span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>handler</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>apiKeyHeader</span> <span class=o>:=</span> <span class=nx>cfg</span><span class=p>.</span><span class=nx>APIKeyHeader</span>
</span></span><span class=line><span class=cl>	<span class=nx>apiKeys</span> <span class=o>:=</span> <span class=nx>cfg</span><span class=p>.</span><span class=nx>APIKeys</span>
</span></span><span class=line><span class=cl>	<span class=nx>apiKeyMaxLen</span> <span class=o>:=</span> <span class=nx>cfg</span><span class=p>.</span><span class=nx>APIKeyMaxLen</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>decodedAPIKeys</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=kt>byte</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>value</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>apiKeys</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>decodedKey</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>hex</span><span class=p>.</span><span class=nf>DecodeString</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>decodedAPIKeys</span><span class=p>[</span><span class=nx>name</span><span class=p>]</span> <span class=p>=</span> <span class=nx>decodedKey</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>next</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span><span class=p>)</span> <span class=nx>http</span><span class=p>.</span><span class=nx>Handler</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>http</span><span class=p>.</span><span class=nf>HandlerFunc</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span> <span class=nx>r</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>r</span><span class=p>.</span><span class=nf>Context</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>apiKey</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>bearerToken</span><span class=p>(</span><span class=nx>r</span><span class=p>,</span> <span class=nx>apiKeyHeader</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>logger</span><span class=p>.</span><span class=nf>Errorw</span><span class=p>(</span><span class=s>&#34;request failed API key authentication&#34;</span><span class=p>,</span> <span class=s>&#34;error&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nf>RespondError</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusUnauthorized</span><span class=p>,</span> <span class=s>&#34;invalid API key&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nf>apiKeyIsValid</span><span class=p>(</span><span class=nx>apiKey</span><span class=p>,</span> <span class=nx>decodedAPIKeys</span><span class=p>);</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				 <span class=nx>hostIP</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>net</span><span class=p>.</span><span class=nf>SplitHostPort</span><span class=p>(</span><span class=nx>r</span><span class=p>.</span><span class=nx>RemoteAddr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=nx>logger</span><span class=p>.</span><span class=nf>Errorw</span><span class=p>(</span><span class=s>&#34;failed to parse remote address&#34;</span><span class=p>,</span> <span class=s>&#34;error&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>						<span class=nx>hostIP</span> <span class=p>=</span> <span class=nx>r</span><span class=p>.</span><span class=nx>RemoteAddr</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=nx>logger</span><span class=p>.</span><span class=nf>Errorw</span><span class=p>(</span><span class=s>&#34;no matching API key found&#34;</span><span class=p>,</span> <span class=s>&#34;remoteIP&#34;</span><span class=p>,</span> <span class=nx>hostIP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>					<span class=nf>RespondError</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>http</span><span class=p>.</span><span class=nx>StatusUnauthorized</span><span class=p>,</span> <span class=s>&#34;invalid api key&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nx>next</span><span class=p>.</span><span class=nf>ServeHTTP</span><span class=p>(</span><span class=nx>w</span><span class=p>,</span> <span class=nx>r</span><span class=p>.</span><span class=nf>WithContext</span><span class=p>(</span><span class=nx>ctx</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=p>},</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// apiKeyIsValid checks if the given API key is valid and returns the principal if it is.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>apiKeyIsValid</span><span class=p>(</span><span class=nx>rawKey</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>availableKeys</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>hash</span> <span class=o>:=</span> <span class=nx>sha256</span><span class=p>.</span><span class=nf>Sum256</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>rawKey</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>key</span> <span class=o>:=</span> <span class=nx>hash</span><span class=p>[:]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>value</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>availableKeys</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>contentEqual</span> <span class=o>:=</span> <span class=nx>subtle</span><span class=p>.</span><span class=nf>ConstantTimeCompare</span><span class=p>(</span><span class=nx>value</span><span class=p>,</span> <span class=nx>key</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>contentEqual</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nx>name</span><span class=p>,</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// bearerToken function omitted...
</span></span></span></code></pre></div><p>Now, the function <code>apiKeyIsValid</code> uses <code>subtle.ConstantTimeCompare</code> to verify the user key against each available key. Since <code>subtle.ConstantTimeCompare</code> operates upon byte slices we don&rsquo;t cast our hash to string anymore and also our reversed index has gone in place of a decoded map.</p><p>The decoding is necessary because the string representation of our key hashes are actually a hexadecimal encoding of the binary value. Hence, we cannot just cast the string to byte slice because Go assumes all strings to be UTF-8 encoded.</p><blockquote><p>Note: for an example on how using a cast instead of the correct decoding function, the result of <code>[]byte("09")</code> is <code>110000111001</code> while <code>hex.DecodeString("09")</code> produces <code>1001</code>. Check out the live example <a href=https://go.dev/play/p/CPy16o7hvDO>here</a>.</p></blockquote><p>The major disadvantage of this solution is that now we need to iterate over all available keys before finding out if the key is incorrect. This doesn&rsquo;t scale well if there are too many keys, however one simple workaround would be to require the client to send an extra header with the key ID/name, e.g. <code>X-App-Key-ID</code>, with which you can find the key in <code>O(1)</code> and then apply the constant time comparison.</p><p>However, there is one subtle (<em>pun intended</em>) behavior from <code>subtle.ConstantTimeCompare</code> that we must be aware before deploying our solution to production. When the byte slices have different lengths, the functions returns earlier without performing the bitwise operations. This is natural because it does an XOR between each pair of bits from each slice, and with slices of different sizes, there would be bits from one slice without a matching pair to be combined with. <strong>Because of it, an adversary could measure that keys with the wrong length have a smaller response time than keys with the correct length, hence leaking the key length</strong>. It would only be a vulnerability if you use a short key that is easily brute-forced, but with a simple 30 character key using the UTF-8 printable characters you would have <code>30^95 = 2.12089515 × 10^140</code> possible keys.</p><p>Finally, we&rsquo;ve built a simple, secure and efficient API Key solution that should handle a lot of uses cases without additional infrastructure or complexity. Using a basic understanding of threats and the Golang standard library, we could do a security-oriented design instead of leaving security as an after-though in an iterative way.</p><hr><p>Photo by <a href="https://unsplash.com/@silas_crioco?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Silas Köhler</a> on <a href="https://unsplash.com/s/photos/key?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://caioferreira.dev/tags/go/>go</a></li><li><a href=https://caioferreira.dev/tags/security/>security</a></li><li><a href=https://caioferreira.dev/tags/authorization/>authorization</a></li><li><a href=https://caioferreira.dev/tags/authentication/>authentication</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Implementing a safe and sound API Key authorization middleware in Go on twitter" href="https://twitter.com/intent/tweet/?text=Implementing%20a%20safe%20and%20sound%20API%20Key%20authorization%20middleware%20in%20Go&amp;url=https%3a%2f%2fcaioferreira.dev%2fposts%2fgolang-secure-api-key-middleware%2f&amp;hashtags=go%2csecurity%2cauthorization%2cauthentication"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Implementing a safe and sound API Key authorization middleware in Go on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcaioferreira.dev%2fposts%2fgolang-secure-api-key-middleware%2f&amp;title=Implementing%20a%20safe%20and%20sound%20API%20Key%20authorization%20middleware%20in%20Go&amp;summary=Implementing%20a%20safe%20and%20sound%20API%20Key%20authorization%20middleware%20in%20Go&amp;source=https%3a%2f%2fcaioferreira.dev%2fposts%2fgolang-secure-api-key-middleware%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Implementing a safe and sound API Key authorization middleware in Go on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcaioferreira.dev%2fposts%2fgolang-secure-api-key-middleware%2f&title=Implementing%20a%20safe%20and%20sound%20API%20Key%20authorization%20middleware%20in%20Go"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://caioferreira.dev/>Simple Made Daily</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>